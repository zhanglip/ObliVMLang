package com.oblivm.backend.generated.knn;

secure int1 lessThan(int  lhs, int rhs) {
    secure int1 res = 0;
    if(lhs < rhs) {
        res = 1;
    }
    return res;
}

/*
	lhs: L方KNN升序 l个元素, 对应input_alice.txt中的二进制，每32位为一个整数
	rhs: R方KNN升序 r个元素，对应input_bob.txt中的二进制，每32位为一个整数
	KNN结果使用debug函数打印到控制台
	返回: 实际knn的k
*/
int main@m@n(int[m] a, int[n] b) {     
	int k = 8;
	//secure int aPtr = 0;
    //secure int bPtr = 0;
    //secure int mPtr;
	//public int bound = m+n;
    //secure int[secure k] merged; 
	//bfor(bound)(mPtr = 0; mPtr < k; mPtr = mPtr + 1) {
	//	if(bPtr < n && (aPtr == m || lessThan(b[bPtr], a[aPtr]) == 1)) {
	//    	merged[mPtr] = b[bPtr];
	//    	bPtr = bPtr + 1;    
	// 	}
	// 	else {
	//      merged[mPtr] = a[aPtr];
 	//      aPtr = aPtr + 1;
	//	}
	//}
	return k;
}
